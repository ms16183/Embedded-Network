<!--ts-->
   * [インターネットの特徴](#インターネットの特徴)
   * [パケット通信方式](#パケット通信方式)
   * [ネットワークシステムの階層化](#ネットワークシステムの階層化)
   * [通信の分類(コネクションの型)](#通信の分類コネクションの型)
   * [IPv4アドレス](#ipv4アドレス)
   * [応用層プログラムの識別: ポート番号](#応用層プログラムの識別-ポート番号)
   * [サーバのポート番号](#サーバのポート番号)
   * [クライアントのポート番号](#クライアントのポート番号)
   * [クライアントサーバ(C/S)モデル](#クライアントサーバcsモデル)
   * [サーバの形態](#サーバの形態)
   * [ソケットインターフェース](#ソケットインターフェース)
   * [サーバとの接続](#サーバとの接続)
   * [ソケットアドレス構造体](#ソケットアドレス構造体)
   * [IPアドレスの指定](#ipアドレスの指定)
   * [バイトオーダー](#バイトオーダー)
   * [バイトオーダー変換関数](#バイトオーダー変換関数)
   * [ソケットアドレス構造体への入出力](#ソケットアドレス構造体への入出力)
   * [バイトオーダー変換関数の必要性](#バイトオーダー変換関数の必要性)
   * [トランスポート層「TCP」](#トランスポート層tcp)
   * [通信形態](#通信形態)
   * [バイトストリームサービス](#バイトストリームサービス)
   * [TCPヘッダ](#tcpヘッダ)
   * [TCPの通信手順(概要)](#tcpの通信手順概要)
   * [コネクション確立](#コネクション確立)
   * [コネクションの切断](#コネクションの切断)
   * [UNIXのプロセス](#unixのプロセス)
   * [高信頼性通信](#高信頼性通信)
   * [TCPエコー並行サーバの実装の注意](#tcpエコー並行サーバの実装の注意)
   * [ネットワーク層IPv6](#ネットワーク層ipv6)
   * [IPv6アドレスの表記方法](#ipv6アドレスの表記方法)
   * [リンクローカルアドレス(LLA)](#リンクローカルアドレスlla)
   * [ユニークローカルアドレス(ULA)](#ユニークローカルアドレスula)
   * [グローバルアドレス(GUA)](#グローバルアドレスgua)

<!--te-->

# インターネットの特徴
- Inter(相互接続された)Net(ネットワーク)
  - 全世界規模のパケット交換網
  - 自立分散型ネットワークシステム(LAN)をルータにより相互接続している．
- 基本プロトコルはTCP/IPv4(IPv6)

# パケット通信方式
- データを分割し，通信パケットにして伝送する．
  - 送信側は，データ(情報)を通信パケット(Packet)に分割する．
  - 受信側は，通信パケットからデータを再構築する．
- 通信パケットにはヘッダ(Header)を付与して伝送する．
- ヘッダは相手の識別番号(Identifier)が設定されている．
  - TCP/IPのIPではIPアドレス(IP Address)

```
 -----------------------------------------------
|                 |                             |
|プロトコルヘッダ |         データ(情報)        |
|        識別番号 |                             |
 -----------------------------------------------

```

# ネットワークシステムの階層化
- 上下関係を持つ複数のプロトコルにより構成
  - 上位層は海藻を使って，より高度な通信を行う．
- 層間インタフェースの標準化
  - 階層を抽象化する．
    - 階層毎に異なるプロトコルを用いることも可能である．
  - 現実的には，完全な抽象化は困難である．
- OSI参照モデル【7層モデル】との対応
  - TCP/IPは5層で定義されている．
- プロトコルスタック
  - 階層図ではプロトコルが積み重なって見える．
- 階層名とレイヤ
  - 下からレイヤnとも呼ばれる．
    - レイヤ3: ネットワーク層
    - レイヤ2: データリンク層
    - レイヤ1: 物理層

# 通信の分類(コネクションの型)
- コネクション(指向)型プロトコル
  - 通信する前に，論理的な通信路(仮想回線，Virtual Circuit)を設定する．
  - 通信品質，透過性，順序が保証される．
    - 電話，TCP
- コネクションレス型プロトコル
  - いきなり送信する．
  - 通信の品質は保証されない(最前努力型通信，ベストエフォート)．
  - 電信，電報，郵便，IP，UDP，イーサネット

# IPv4アドレス
- ホストを識別する番号
  - 32bit
  - ユニーク
- IPv4アドレスの表記
  - 32bitを1オクテット(=8bit)単位に10進数で表記する．
  - 区切りは`.`

# 応用層プログラムの識別: ポート番号
- 接続相手の応用プロセスを識別する番号
  - 応用プロセス毎に一つしかない．ユニークな番号が必要である．
  - TCP/IPではポート番号を用いる．
    - `netstat -an`コマンドなどでは以下のように表示される．
      - FreeBSD: `172.25.8.130.53`
      - Windows: `172.25.8.130:53`

# サーバのポート番号
- Well Known Port
  - インターネットの多くのコンピュータで利用されているサーバ(サービス)用のポート番号
  - 本来は0から1,023であるが不足している．

- 登録ポート(Registerd Port)
  - 不足しているWell Known Portを補うため1,024以降の番号も，使用するサーバが決められている．
    - 8080: WWW プロキシサーバ

# クライアントのポート番号
- エフェメラルポート(Ephemeral Port，短命ポート)
- 現在は特に決まっていない．
  - ランダムに設定する．

# クライアントサーバ(C/S)モデル
- 応用層のプログラム
- ネットワーク利用形態モデルの一つ
  - サーバは，サービスを提供する．
    - Well Knwn POrtで受動オープンする．
    - OS起動時，自動的に起動されるプロセス(daemon)である．
  - クライアントは，サービスを要求する．
    - Well Known Portに対して能動オープンする．
    - WindowsではMAPI等のAPIも使用されるが，ソケットインターフェースが一般的である．
- 一台のホストが，あるサービスではサーバ，あるサービスではクライアントとなれる．
  - クライアントとサーバは対等な関係にある．
- 別のサーバに要求を転送して，処理させることも可能である．

# サーバの形態
- 反復サーバ
  - サーバプロセスが自分で要求を処理する．
    - 処理が終わるまでは，次の要求を処理できない．
    - 処理が短時間で終わる場合に有効である．
- 並行サーバ
  - 子プロセスを生成して，子プロセスに要求を処理させる．
    - すぐに次の要求を処理できる．
    - 多くのメモリやプロセスを必要とする．

# ソケットインターフェース
- UNIX(Windows)での通信プログラムの基本インターフェース
- 汎用の通信APIとして設計されている．
  - ネットワークシステムはインターネットに限らない．
  - インターネットが普及した現在では，無駄が多い．
- 応用層の最下部
- 通信ソケットを作り，ソケット間をネットワークで接続する．
- TCPではファイルアクセスと同じように扱える．

# サーバとの接続
- C/Sモデルでクライアントプログラムは，ネットワーク上にあるサーバPCのサーバプログラムに接続しなければならない．
  - サーバPCの指定には，IPアドレスが使用される．
    - 一般的にはDNSにより，ホスト名からIPアドレスに変換する．
  - サーバプログラム(プロセス，デーモン，サービス)の指定は，ポート番号が使用される．
    - 一般的にWell Known Portである．
- クライアントプログラム側にも，IPアドレスとポート番号が必要である．
  - サーバは，この情報を使ってクライアントとの通信を行う．

# ソケットアドレス構造体
- ソケットインタフェースでは，ソケットアドレス構造体にIPアドレスとポート番号等を設定し，ソケット関数の引数として使われる．
  - クライアント・サーバのどちらでも使用されている．
  - ネットワークシステムに対応したソケットアドレス構造体が定義されている．
    - IPv6用: `struct sockaddr_in6`
    - IPv4用: `struct sockaddr_in`

# IPアドレスの指定
- クライアントプログラムでは，接続するサーバのIPアドレスの指定は必須である．
- サーバ側では通常IPアドレスを指定しない．

# バイトオーダー
- 複数のバイトデータをメモリに配置するための順序
  - ビッグエンディアン
    - 最下位バイトを上位アドレスに配置する．
  - リトルエンディアン
    - 最下位バイトを下位アドレスに配置する．
    - 16進数2桁毎に順番が逆転する．
  - ネットワークのバイトオーダーはビッグエンディアンである．

# バイトオーダー変換関数
- プログラムの移植性を高めるため，常に指定するべきである．
  - 定義はマクロである．リトルエンディアンはバイトを反転するようにしている．

# ソケットアドレス構造体への入出力
- 各メンバへの書き込み
  -  ネットワークバイトオーダに変換して書き込む．
    - `s->sin_addr = htonl(INADDR_ANY);`
    - `s->sin_port = htons(port);`
- 各メンバへの読み出し
  - ホストバイトOooDaに変換して読み出す．
    - `ipaddr = ntonl(s->sin_addr);`
    - `portno = htohs(s->sin_port);`

# バイトオーダー変換関数の必要性
- 不必要
  - 内部で変換も行ってくれる関数
    - `inet_pton`
    - `getservebyname`
- 必要
  - 一般の文字列操作関数の出力
    - `strtol`

# トランスポート層「TCP」
- 信頼性のあるコネクション型プロトコル
  - 上位層に対して仮装的な通信路(VC: Virtual Circuit)を提供する．
- 信頼性を提供するための機能
  - 誤り制御
  - 順序制御
  - フロー制御と輻輳制御
- その他機能
  - 全二重通信
  - バイトストリームサービス

# 通信形態
- 二重通信
  - 送信も受信も可能
- 全二重通信
  - 同時に送受信が可能
- 半二重通信
  - 片方の機器のみが送信可能
  - 受信中は送信不可

# バイトストリームサービス
- 受信側は，流れてくるデータの区切りが見えない．
  - 何オクテット受信するかわからない．
  - 受信終了は，受信したデータ量が0となることで判断する．
- 送信側も，今出力したデータの塊がそのまま受信側に伝わるかわからない．
  - 100オクテットのデータを送信したからといって，受信側にそのまま100オクテットのデータが届くとは限らない．　

# TCPヘッダ
- 送信元ポート番号(16bit)
- 受信元ポート番号(32bit)
- シーケンス番号\[SEQ\](32bit)
  - TCPセグメントのオフセット(データ部の1オクテット目の，送信開始からの変位)である．
    - 送信側から受信側に通知される．
    - コネクション確立時に，互いの初期シーケンス番号(ISN; Initial Sequence Number)を交換する．
- 確認応答番号\[ACK\[\](32bit)
  - ACK = SEQ + データ長(L)を送信側に通知する．
  - ACK-1まで正常に受信したことを表す．
  - ACKは次に受診を期待するSEQということでもある．
- 制御ビット(6bit)
  - SYN: 同期ビット，コネクション確立
  - FIN: 終了ビット，コネクション終了
  - PSH: プッシュビット，送信バッファが空になった．
- ウィンドサイズ(16bit)
  - 受信側から受診可能なデータ量を送信側に通知する．
  - スライドウィンドウ制御用

# TCPの通信手順(概要)
- コネクション(VC)の確立
- データの送受信
- コネクション(VC)の切断

# コネクション確立
- 3ウェイハンドシェーク
  - クライアントとサーバ間でセグメントを3回交換する．
  - SYNセグメントとACKセグメントを交換する．
  - 互いの初期シーケンス番号を交換する．
- TCPコネクション管理構造体(`tcpcb`)を確保する．
- 受動オープン(サーバが実行する)
  - クライアントからのコネクション確立要求を待っている状態であること．
- 能動オープン(クライアントが実行する)
  - サーバへのコネクション確立要求を実行する．

# コネクションの切断
- 送信するデータがないことを相手に通知する．
  - 先に切断するのはクライアントでもサーバでも，どちらでも良い．
  - WWWはサーバから切断する．
- FINセグメントとACKセグメントを交換する．
- ハーフクローズ(一方のみクローズ)機能
  - 相手の送信が終わっても，送信可能である．
- TCPコネクション管理構造体(`tcpcb`)を解放する．

# UNIXのプロセス
- プロセスは実行中のプログラム実態で，PID(Process ID)により識別される．
  - ある時点では，全てのプロセスにユニークなPIDが割り当てられている．
  - `ps`コマンドで，ユーザに関係するプロセスの一覧を表示できる．

- プロセスは`fork`で生成する．
  - UNIXでは`fork`を呼び出したプロセス(親プロセス)をそのままコピーして新しいプロセス(子プロセス)を生成する．

- 子プロセスは親プロセスと個別に実行する．
  - スケジューリングアルゴリズムに従ってCPUが割り当てられる．
- `fork`関数の戻り値によって親と子プロセスを区別できる．
  - 0: 子プロセス
  - 1以上: 子プロセスのPID

# 高信頼性通信
- 正常に受信できたことを確認してデータの送受信を行う．
  - シーケンス番号(SEQ)
    - 送信したデータのオフセットを受信側に送る．
  - 確認応答番号(ACK)
    - 受信済みデータのオフセット+データ長を送信側に送る．
- 正常に受信できない原因
  - 配送途中での破棄などがある．
    - SWハブやルータにおける受信バッファの溢れ．
    - 通信回線でのノイズによるデータ誤り．
- 送信と同時に再送タイマーをスタートする．
  - タイムアウトしたら再送する．
- 再送は最大12回，時間的には標準で約9分である．
  - 再送毎にタイムアウト値をある一定の値(標準で約1分)まで2倍にする．

# TCPエコー並行サーバの実装の注意
- 並行サーバの処理形態
  - `fork`で子プロセスを生成し，処理は子プロセスで行う．
- 問題点
  - 子プロセスがゾンビプロセスとして残る．
    - プロセスID，メモリを消費するためシステムダウン発生の恐れがある．
- 解決方法
  - 子プロセス終了のシグナルを送信する．
  - 子プロセスの終了状態を取得する．

# ネットワーク層IPv6
- アドレス割り当ての自動化
  - ネットワークに接続すると自動的にアドレスを設定する．
    - SLAAC(StateLess Adress Auto Configuration)
  - RA(ルータ通知)，HDCPv6がすでに対応している．
- 階層化されたアドレス割り当て
  - アドレス割り当てが階層化された．
    - 経路情報が集約化されるため，経路選択が容易になる．

# IPv6アドレスの表記方法
- 16進数で表記する．
- 16ビット毎に`:`で区切る．
  - fe80:0000:0000:0000:0201:02ff:fe8d:1a90
- 上位の0は省略可能である．
  - fe80:0:0:0:201:2ff:fe8d:1a90
- 1箇所だけ連続する:0:を::に省略可能である．
  - fe80::201:2ff:fe8d:1a90

# リンクローカルアドレス(LLA)
- Link Local (Unicast) Adress
- プレフィックスはfe80::/64
- LAN内のみ有効である．
  - 全てのLANでプレフィックスが同じであり，この段階では区別できない．
  - ネットワークインターフェース(IFID)の指定が必要である．
  - ネットワーク間利用を想定したものである．
- 自己完結型であり，自動設定が可能である．

# ユニークローカルアドレス(ULA)
- Unique Local (Unicast) Adress
- プレフィックスはfd+<グローバルID>:<SLA>:/64
- サイト(組織)内のみ有効である．
  - 一般にサイト内の通信のみに使用する．
  - 各LAN固有の<SLA>(サブネットID)を割り当てるので，各LANを区別できる．
  - インターフェース名(番号)の指定は不要である．
- ルータ通知で自動設定するか，手動で設定する．

# グローバルアドレス(GUA)
- Global Unicast Adress
- プレフィックスは1::/3(2進数では001)
- GRP(Global Routing Prefix)
  - 階層化され，経路情報を集約することで経路選択の負荷を軽減している．
- インターネット全体で有効である．
  - インターネット接続時に利用する．
- ルータ通知で自動設定するか，手動で設定する．
